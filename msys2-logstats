#!/usr/bin/env python3
# Expects traefik json access logs either by passing a log file as the first argument, or via stdin

import json
import re
import sys
import argparse
from collections import Counter
from typing import List, Tuple
from dataclasses import dataclass

from tabulate import tabulate
import requests
from netaddr import IPSet, IPAddress


@dataclass
class LogEntry:
    ClientHost: str
    DownstreamStatus: int
    RequestHost: str
    RequestMethod: str
    RequestPath: str
    RequestProtocol: str
    UserAgent: str
    time: str


@dataclass
class UserAgent:
    pacman_version: Tuple[int, int, int]
    windows_version: Tuple[int, int]
    build_number: int
    is_wow64: bool
    cpu_arch: str
    libalpm_version: Tuple[int, int, int]


@dataclass
class ClientInfo:
    pacman_version: str
    windows_edition: str
    cpu_arch: str
    is_wow64: str
    user_agent: UserAgent
    ci: str


def is_valid_user_agent(ua: str) -> bool:
    return ua.startswith("pacman") and "_NT-" in ua


def parse_user_agent(ua: str) -> UserAgent:
    assert is_valid_user_agent(ua)
    m = re.match(r"pacman/([^\s]+) \(([^-]+)-([^-]+)-?([0-9]+|)-?(.+|) ([^)]+)\) libalpm/(.+)", ua)
    assert m is not None
    pacman_version, _, windows_version, build_number, wow64, arch, alpm_version = m.groups()

    pacman_version = tuple(map(int, pacman_version.split(".")))
    windows_version = tuple(map(int, windows_version.split(".")))
    build_number = int(build_number or "-1")
    is_wow64 = bool(wow64)
    cpu_arch = arch
    alpm_version = tuple(map(int, alpm_version.split(".")))

    return UserAgent(
        pacman_version,
        windows_version,
        build_number,
        is_wow64,
        cpu_arch,
        alpm_version
    )


def test_parse_user_agent():
    ua = "pacman/6.0.1 (MSYS_NT-10.0-19042 x86_64) libalpm/13.0.1"
    assert parse_user_agent(ua).pacman_version == (6, 0, 1)
    ua = "pacman/6.0.1 (MSYS_NT-10.0-19042-WOW64 i686) libalpm/13.0.1"
    assert parse_user_agent(ua).is_wow64
    assert parse_user_agent(ua).build_number == 19042
    ua = "pacman/5.2.1 (MSYS_NT-6.1-7601-WOW64 i686) libalpm/12.0.1"
    assert parse_user_agent(ua).is_wow64
    assert parse_user_agent(ua).build_number == 7601
    ua = "pacman/5.1.0 (MINGW64_NT-10.0 x86_64) libalpm/11.0.0"
    assert parse_user_agent(ua).build_number == -1
    assert parse_user_agent(ua).cpu_arch == "x86_64"
    ua = "pacman/5.0.1 (UCRT64_NT-10.0-WOW i686) libalpm/10.0.1"
    assert parse_user_agent(ua).build_number == -1
    assert parse_user_agent(ua).is_wow64
    assert parse_user_agent(ua).cpu_arch == "i686"


def get_windows_edition(ua: UserAgent):
    if ua.windows_version >= (10, 0):
        if ua.build_number >= 22000:
            return "11"
        else:
            return "10"
    elif ua.windows_version == (6, 1):
        return "7"
    elif ua.windows_version == (6, 2):
        return "8"
    elif ua.windows_version == (6, 3):
        return "8.1"
    else:
        assert 0, ua


def get_ci_networks():
    r = requests.get("https://api.github.com/meta")
    r.raise_for_status()
    gha = IPSet(r.json()["actions"])

    r = requests.get("https://www.appveyor.com/ips.json")
    r.raise_for_status()
    appveyor = IPSet(r.json())

    r = requests.get("https://www.gstatic.com/ipranges/cloud.json")
    r.raise_for_status()
    prefixes = set()
    for prefix in r.json()["prefixes"]:
        prefixes.add(prefix.get("ipv4Prefix", prefix.get("ipv6Prefix")))
    gcp = IPSet(prefixes)

    r = requests.get("https://ip-ranges.amazonaws.com/ip-ranges.json")
    r.raise_for_status()
    prefixes = set()
    for prefix in r.json()["prefixes"]:
        prefixes.add(prefix["ip_prefix"])
    for prefix in r.json()["ipv6_prefixes"]:
        prefixes.add(prefix["ipv6_prefix"])
    aws = IPSet(prefixes)

    r = requests.get(
        "https://download.microsoft.com/download/7/1/D/71D86715-5596-4529-9B13-DA13A5DE5B63/ServiceTags_Public_20220124.json")
    r.raise_for_status()
    prefixes = set()
    for value in r.json()["values"]:
        for nw in value["properties"]["addressPrefixes"]:
            prefixes.add(nw)
    azure = IPSet(prefixes)

    return {"GHA": gha, "APPV": appveyor, "GCP": gcp, "AWS": aws, "AZ": azure}


def main(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument('infile', nargs='?', type=argparse.FileType('r', encoding="utf-8"), default=sys.stdin)
    parser.add_argument('--ci', action='store_true', help='detect potential CI/cloud IP ranges')
    parser.add_argument('--skip-ci', action='store_true', help='skip CI/cloud IP ranges')
    args = parser.parse_args(argv[1:])

    if args.skip_ci:
        args.ci = True

    entries: List[LogEntry] = []
    with args.infile as h:
        for line in h:
            if not line.startswith("{"):
                continue
            decoded = json.loads(line)
            if "RequestHost" not in decoded or "request_User-Agent" not in decoded:
                continue
            entries.append(LogEntry(
                decoded["ClientHost"],
                decoded["DownstreamStatus"],
                decoded["RequestHost"],
                decoded["RequestMethod"],
                decoded["RequestPath"],
                decoded["RequestProtocol"],
                decoded["request_User-Agent"],
                decoded["time"],
            ))

    def user_key(entry):
        # only take the system part of the UA, so we don't count
        # a client twice if it upgrades during a job for example
        system_id = "".join(entry.UserAgent.split()[1:3])
        return system_id + entry.ClientHost

    grouped = {}
    for entry in entries:
        if entry.RequestHost not in ["repo.msys2.org", "mirror.msys2.org"] or entry.RequestMethod != "GET":
            continue
        if not is_valid_user_agent(entry.UserAgent):
            continue
        key = user_key(entry)
        grouped.setdefault(key, []).append(entry)

    def get_repo_for_path(path: str) -> str:
        repo = path.rsplit("/", 1)[0].lstrip("/")
        if repo == "mingw/i686":
            repo = "mingw/mingw32"
        elif repo == "mingw/x86_64":
            repo = "mingw/mingw64"

        if path.endswith(".db") or ".db." in path:
            repo += "/db"
        elif path.endswith(".files") or ".files." in path:
            repo += "/db"

        return repo

    ci_networks = {}
    if args.ci:
        ci_networks = get_ci_networks()

    def get_ci(ip_addr: str) -> str:
        ip = IPAddress(ip_addr)
        for name, ipset in ci_networks.items():
            if ip in ipset:
                return name
        return ""

    first = entries[0].time
    last = entries[0].time
    requests = 0
    repos = Counter()
    ci_systems = Counter()
    clients: List[ClientInfo] = []
    for entries in grouped.values():
        user_agent = parse_user_agent(entries[0].UserAgent)
        ci = get_ci(entries[0].ClientHost)
        if args.skip_ci and ci:
            continue
        ui = ClientInfo(
            ".".join(map(str, user_agent.pacman_version)),
            get_windows_edition(user_agent),
            user_agent.cpu_arch,
            str(user_agent.is_wow64),
            user_agent,
            ci
        )
        clients.append(ui)
        for entry in entries:
            requests += 1
            if entry.time < first:
                first = entry.time
            if entry.time > last:
                last = entry.time
            repos.update([(get_repo_for_path(entry.RequestPath), ui.ci)])
            ci_systems.update([ui.ci])

    # Log info
    print(tabulate([["Start", first], ["End", last], ["Requests", requests], ["Clients", len(clients)]]))

    # Repos
    table = []
    for (repo, ci), count in repos.most_common():
        pcnt = count / requests * 100
        table.append([repo, ci, f"{pcnt:.2f}%", f"{count}"])
    print()
    print(tabulate(table, ["Repo", "CI", "Percent", "Requests"], stralign="right", numalign="right"))

    # CI Systems
    table = []
    for ci, count in ci_systems.most_common():
        pcnt = count / requests * 100
        table.append([ci, f"{pcnt:.2f}%", f"{count}"])
    print()
    print(tabulate(table, ["CI", "Percent", "Requests"], stralign="right", numalign="right"))

    # Windows versions
    table = []
    for (edition, ci), count in Counter([(u.windows_edition, u.ci) for u in clients]).most_common():
        pcnt = count / len(clients) * 100
        table.append([edition, ci, f"{pcnt:.2f}%", f"{count}"])
    print()
    print(tabulate(table, ["Windows", "CI", "Percent", "Clients"], stralign="right", numalign="right"))

    # Windows versions detailed
    table = []
    for (windows_version, build_number, ci), count in Counter(
            [(u.user_agent.windows_version, u.user_agent.build_number, u.ci) for u in clients]).most_common():
        pcnt = count / len(clients) * 100
        table.append([".".join(map(str, windows_version)), build_number, ci, f"{pcnt:.2f}%", f"{count}"])
    print()
    print(tabulate(table, ["Win Ver", "Build Number", "CI", "Percent", "Clients"], stralign="right", numalign="right"))

    # Pacman
    table = []
    for (version, ci), count in Counter([(u.pacman_version, u.ci) for u in clients]).most_common():
        pcnt = count / len(clients) * 100
        table.append([version, ci, f"{pcnt:.2f}%", f"{count}"])
    print()
    print(tabulate(table, ["Pacman Ver", "CI", "Percent", "Clients"], stralign="right", numalign="right"))

    # CPU Arch
    table = []
    for (cpu_arch, is_wow64, ci), count in Counter([(u.cpu_arch, u.is_wow64, u.ci) for u in clients]).most_common():
        pcnt = count / len(clients) * 100
        table.append([cpu_arch, is_wow64, ci, f"{pcnt:.2f}%", f"{count}"])
    print()
    print(tabulate(table, ["Arch", "WOW64", "CI", "Percent", "Clients"], stralign="right", numalign="right"))


if __name__ == "__main__":
    main(sys.argv)
